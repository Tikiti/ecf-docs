"let signedInfoXmlFormat = '<SignedInfo><CanonicalizationMethod"
"Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315"" />'+"
"'<SignatureMethod"
"Algorithm=""http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"" />'+"
"'<Reference URI="""">'+"
"'<Transforms>'+"
"'<Transform"
"Algorithm=""http://www.w3.org/2000/09/xmldsig#enveloped-signature"" />'+"
"'</Transforms>'+"
"'<DigestMethod Algorithm=""http://www.w3.org/2001/04/xmlenc#sha256"" />'+"
"'<DigestValue>' + digestValue + '</DigestValue>'+"
"'</Reference>'+"
"'</SignedInfo>';"
"let firmado = signatureXmlFormat + signedInfoXmlFormat + keyinfoXmlFormat + '</Signature>';"
"let indice = xml.search ('</ECF>');"
"let xmlSinFirmado = xml.substring(0, indice) + firmado + xml.substring(indice);"
"return xmlSinFirmado;"
"}"
"//Permite convertir a Pem"
"private convertToPem(p12ArrayBuffer, password) {"
"let p12Asn1 = forge.asn1.fromDer(p12ArrayBuffer);"
"let p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, false, password);"
"let pemKey = this.getKeyFromP12(p12, password);"
"let _a = this.getCertificateFromP12(p12), pemCertificate = _a.pemCertificate, commonName ="
"_a.commonName;"
"return { pemKey: pemKey, pemCertificate: pemCertificate, commonName: commonName };"
"}"
"// Obtiene la llave de un p12"
"private getKeyFromP12(p12, password) {"
"var keyData = p12.getBags({ bagType: forge.pki.oids.pkcs8ShroudedKeyBag },"
"password);"
"var pkcs8Key = keyData[forge.pki.oids.pkcs8ShroudedKeyBag][0];"
"if (typeof pkcs8Key === 'undefined') {"
"pkcs8Key = keyData[forge.pki.oids.keyBag][0];"
"}"
"if (typeof pkcs8Key === 'undefined') {"
"throw new Error('Unable to get private key.');"
"}"
"var pemKey = forge.pki.privateKeyToPem(pkcs8Key.key);"
"pemKey = pemKey.replace(/\r\n/g, '');"
"return pemKey;"
"}"
